#include "TransfersWidget.h"
#include "ui_TransfersWidget.h"
#include "MegaApplication.h"
#include <QTimer>

using namespace mega;

TransfersWidget::TransfersWidget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::TransfersWidget)
{
    ui->setupUi(this);
    this->model = nullptr;
    this->model2 = nullptr;
    tDelegate = nullptr;
    tDelegate2 = nullptr;
    isPaused = false;
    app = (MegaApplication *)qApp;
}

void TransfersWidget::setupTransfers(std::shared_ptr<MegaTransferData> transferData, QTransfersModel::ModelType type)
{
    mType = type;
    model = new QActiveTransfersModel(type, transferData);

    connect(model, SIGNAL(noTransfers()), this, SLOT(noTransfers()));
    connect(model, SIGNAL(onTransferAdded()), this, SLOT(onTransferAdded()));

    noTransfers();
    configureTransferView();

    if ((type == MegaTransfer::TYPE_DOWNLOAD && transferData->getNumDownloads())
            || (type == MegaTransfer::TYPE_UPLOAD && transferData->getNumUploads()))
    {
        onTransferAdded();
    }
}

void TransfersWidget::setupTransfers()
{
    model2 = new QTransfersModel2(this);
    mProxyModel = new TransfersSortFilterProxyModel(this);
    mProxyModel->setSourceModel(model2);

    configureTransferView();
    onTransferAdded();
}

void TransfersWidget::setupFinishedTransfers(QList<MegaTransfer* > transferData, QTransfersModel::ModelType modelType)
{
    mType = modelType;
    model = new QFinishedTransfersModel(transferData, modelType);
    connect(model, SIGNAL(noTransfers()), this, SLOT(noTransfers()));
    connect(model, SIGNAL(onTransferAdded()), this, SLOT(onTransferAdded()));
    // Subscribe to MegaApplication for changes on finished transfers generated by other finished model to keep consistency
    connect(app, SIGNAL(clearAllFinishedTransfers()), model, SLOT(removeAllTransfers()));
    connect(app, SIGNAL(clearFinishedTransfer(int)),  model, SLOT(removeTransferByTag(int)));

    noTransfers();
    configureTransferView();

    if (transferData.size())
    {
        onTransferAdded();
    }
}

void TransfersWidget::refreshTransferItems()
{
    if (model) model->refreshTransfers();
}

TransfersWidget::~TransfersWidget()
{
    delete ui;
    if (tDelegate) delete tDelegate;
    if (tDelegate2) delete tDelegate2;
    if (model) delete model;
    if (model2) delete model2;
    if (mProxyModel) delete mProxyModel;
}

bool TransfersWidget::areTransfersActive()
{
    return model && model->rowCount(QModelIndex()) != 0;
}

void TransfersWidget::configureTransferView()
{
    if (!model && !model2)
    {
        return;
    }

    if (model)
    {
        tDelegate = new MegaTransferDelegate(model, this);
        ui->tvTransfers->setup(mType);
        ui->tvTransfers->setItemDelegate(tDelegate);
        ui->tvTransfers->setModel(model);

    }
    else
    {
        tDelegate2 = new MegaTransferDelegate2(mProxyModel, ui->tvTransfers, this);
        ui->tvTransfers->setup(this);
        ui->tvTransfers->setItemDelegate(tDelegate2);
        ui->tvTransfers->setModel(mProxyModel);
        model2->initModel();
        mProxyModel->setDynamicSortFilter(true);
    }

    ui->tvTransfers->setDragEnabled(true);
    ui->tvTransfers->viewport()->setAcceptDrops(true);
    ui->tvTransfers->setDropIndicatorShown(true);
    ui->tvTransfers->setDragDropMode(QAbstractItemView::InternalMove);
}

void TransfersWidget::pausedTransfers(bool paused)
{
    isPaused = paused;
    if (model && model->rowCount(QModelIndex()) == 0)
    {
        noTransfers();
    }
    else
    {
        ui->sWidget->setCurrentWidget(ui->pTransfers);
    }
}

void TransfersWidget::disableGetLink(bool disable)
{
    ui->tvTransfers->disableGetLink(disable);
}

QTransfersModel *TransfersWidget::getModel()
{
    return model;
}

QTransfersModel2* TransfersWidget::getModel2()
{
    return model2;
}


void TransfersWidget::noTransfers()
{
    if (isPaused)
    {
        ui->pNoTransfers->setState(TransfersStateInfoWidget::PAUSED);
    }
    else
    {
        switch (mType)
        {
            case QTransfersModel::TYPE_DOWNLOAD:
                ui->pNoTransfers->setState(TransfersStateInfoWidget::NO_DOWNLOADS);
                break;
            case QTransfersModel::TYPE_UPLOAD:
                ui->pNoTransfers->setState(TransfersStateInfoWidget::NO_UPLOADS);
                break;
            default:
                ui->pNoTransfers->setState(TransfersStateInfoWidget::NO_TRANSFERS);
                break;
        }
    }

    ui->sWidget->setCurrentWidget(ui->pNoTransfers);
}

void TransfersWidget::on_tPauseResumeAll_clicked()
{
    QModelIndexList selection = ui->tvTransfers->selectionModel()->selectedRows();

    static bool isPaused(true);

    isPaused = !isPaused;

    ui->tPauseResumeAll->setIcon(isPaused ?
                                     QIcon(QString::fromUtf8(":/images/ico_resume_transfers_state.png"))
                                   : QIcon(QString::fromUtf8(":/images/ico_pause_transfers_state.png")));
    ui->tPauseResumeAll->setToolTip(isPaused ?
                                        tr("Resume transfers")
                                      : tr("Pause transfers"));

    if (selection.size() > 0)
    {
        for (auto index : selection)
        {
            if (index.isValid())
            {
                auto d (qvariant_cast<TransferItem2>(index.data()).getTransferData());
                if ((d->mState == MegaTransfer::STATE_PAUSED
                     || d->mState == MegaTransfer::STATE_ACTIVE
                     || d->mState == MegaTransfer::STATE_QUEUED
                     || d->mState == MegaTransfer::STATE_RETRYING)
                        && ((d->mState == MegaTransfer::STATE_PAUSED) != isPaused))                {
                    d->mMegaApi->pauseTransferByTag(d->mTag, isPaused);
                }
            }
        }
        ui->tvTransfers->clearSelection();
    }
    else
    {
        for (auto row (0); row <= mProxyModel->rowCount()-1; ++row)
        {
            const TransferItem2 transferItem (
                        qvariant_cast<TransferItem2>(mProxyModel->data(mProxyModel->index(
                                                                           row, 0, QModelIndex()),
                                                                       Qt::DisplayRole)));
            auto d(transferItem.getTransferData());
            if ((d->mState == MegaTransfer::STATE_PAUSED
                 || d->mState == MegaTransfer::STATE_ACTIVE
                 || d->mState == MegaTransfer::STATE_QUEUED
                 || d->mState == MegaTransfer::STATE_RETRYING)
                    && ((d->mState == MegaTransfer::STATE_PAUSED) != isPaused))
            {
                d->mMegaApi->pauseTransferByTag(d->mTag, isPaused);
            }
        }
    }
}

void TransfersWidget::on_tCancelAll_clicked()
{
    QModelIndexList selection = ui->tvTransfers->selectionModel()->selectedRows();

    QList<QExplicitlySharedDataPointer<TransferData>> pool;
    int poolState;
    int row;

    // If row selected, process only these rows
    if (selection.size() > 0)
    {
        // Reverse sort to keep indexes valid after deletion
        std::sort(selection.rbegin(), selection.rend());

        for (auto index : selection)
        {
            if (index.isValid())
            {
                const TransferItem2 transferItem (
                            qvariant_cast<TransferItem2>(index.data(Qt::DisplayRole)));

                auto state (transferItem.getState());

                if (pool.isEmpty())
                {
                    poolState = state;
                    row = index.row() + 1;
                }

                if (state != poolState || (index.row() != (row-1)))
                {
                    clearOrCancel(pool, poolState, row);
                    poolState = state;
                    pool.clear();
                }
                pool += transferItem.getTransferData();
                row = index.row();
            }
        }
    }
    // else process all available rows
    else
    {
        for (row = mProxyModel->rowCount(QModelIndex())-1; row >= 0; --row)
        {
            const TransferItem2 transferItem (
                        qvariant_cast<TransferItem2>(mProxyModel->data(mProxyModel->index(
                                                                           row, 0, QModelIndex()),
                                                                       Qt::DisplayRole)));
            auto state (transferItem.getState());

            if (pool.isEmpty())
            {
                poolState = state;
            }

            if (state != poolState)
            {
                clearOrCancel(pool, poolState, row);
                poolState = state;
                pool.clear();
            }
            pool += transferItem.getTransferData();
        }
        row = 0;
    }

    // Flush pool if not empty
    if (!pool.isEmpty())
    {
        clearOrCancel(pool, poolState, row);
    }
}

void TransfersWidget::clearOrCancel(const QList<QExplicitlySharedDataPointer<TransferData>>& pool, int state, int firstRow)
{

    // Clear if finished, cancel if not.
    if (state == MegaTransfer::STATE_COMPLETED
            || state == MegaTransfer::STATE_CANCELLED
            || state == MegaTransfer::STATE_FAILED)
    {
        emit clearTransfers(firstRow, pool.size());
    }
    else if (state != MegaTransfer::STATE_COMPLETING)
    {
        for (auto transfer : pool)
        {
            transfer->mMegaApi->cancelTransferByTag(transfer->mTag);
        }
    }
}

void TransfersWidget::onTransferAdded()
{
    ui->sWidget->setCurrentWidget(ui->pTransfers);
    ui->tvTransfers->scrollToTop();
}

void TransfersWidget::textFilterChanged(QRegExp regExp)
{
    mProxyModel->setFilterRegExp(regExp);
    ui->tvTransfers->scrollToTop();
}

void TransfersWidget::fileTypeFilterChanged(QSet<TransferData::FileTypes> fileTypes)
{
    mProxyModel->setFileType(fileTypes);
    ui->tvTransfers->scrollToTop();
}

void TransfersWidget::transferStateFilterChanged(QSet<int> transferStates)
{
    mProxyModel->setTransferState(transferStates);
    ui->tvTransfers->scrollToTop();
}

void TransfersWidget::transferTypeFilterChanged(QSet<int> transferTypes)
{
    mProxyModel->setTransferType(transferTypes);
    ui->tvTransfers->scrollToTop();
}

int TransfersWidget::rowCount()
{
    return ui->tvTransfers->model()->rowCount(QModelIndex());
}

void TransfersWidget::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
    {
        ui->retranslateUi(this);
    }
    QWidget::changeEvent(event);
}
